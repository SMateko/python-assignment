{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ef1b58e1-6754-45b8-bb7b-64de4fd9f237",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "import bokeh.plotting as bp\n",
    "from bokeh.models import ColumnDataSource\n",
    "\n",
    "# Class for performing Least Squares Regression\n",
    "class LeastSquaresRegression:\n",
    "    def __init__(self, x_values, y_values):\n",
    "        self.x_values, self.y_values = x_values, y_values\n",
    "\n",
    "    def fit(self, degree):\n",
    "        if len(self.x_values) != len(self.y_values):\n",
    "            raise ValueError(\"Length of x_values must match the length of y_values.\")\n",
    "        return np.polyfit(self.x_values, self.y_values, degree)\n",
    "\n",
    "# Class for selecting ideal functions and visualizing results\n",
    "class IdealFunctionSelector:\n",
    "    def __init__(self, training_data_path, ideal_functions_path, test_data_path):\n",
    "        self.training_data_path, self.ideal_functions_path, self.test_data_path = training_data_path, ideal_functions_path, test_data_path\n",
    "        self.training_data, self.ideal_functions, self.test_data, self.selected_functions = None, None, None, None\n",
    "\n",
    "    # Preprocess training, ideal, and test data\n",
    "    def preprocess_data(self):\n",
    "        self.training_data, self.ideal_functions, self.test_data = [pd.read_csv(path) for path in (self.training_data_path, self.ideal_functions_path, self.test_data_path)]\n",
    "\n",
    "    # Select ideal functions using least squares regression\n",
    "    def select_ideal_functions(self):\n",
    "        x_values, y_values = self.training_data['x'].values, self.training_data[['y1', 'y2', 'y3', 'y4']].values.T\n",
    "        self.selected_functions = [(f'Y{i}', LeastSquaresRegression(x_values, y_values[i-1]).fit(min(i + 1, len(self.ideal_functions.columns) - 1) - 1)) for i in range(1, min(51, len(y_values) + 1))]\n",
    "\n",
    "    # Get selected ideal functions\n",
    "    def get_selected_functions(self):\n",
    "        return self.selected_functions\n",
    "\n",
    "    # Predict ideal function numbers for test data\n",
    "    def predict_ideal_function_nos(self):\n",
    "        if 'x' not in self.test_data.columns:\n",
    "            raise ValueError(\"Test data must have a column named 'x'.\")\n",
    "        x_values = self.test_data['x'].values\n",
    "        return pd.Series([min(self.selected_functions, key=lambda func: abs(func[1][0] - x_value))[0] for x_value in x_values], name=\"ideal_functions_df\")\n",
    "\n",
    "    # Visualize results using Bokeh\n",
    "    def visualize_results(self, mapped_test_data, filename=\"ideal_functions.html\"):\n",
    "        p = bp.figure(title=\"Test Data vs Ideal Functions\", x_axis_label=\"x\", y_axis_label=\"y\")\n",
    "        source = ColumnDataSource(mapped_test_data)\n",
    "        p.scatter(x='x', y='y', size=10, color=\"blue\", alpha=0.5, legend_label=\"Test Data\", source=source)\n",
    "        ys_columns = list(self.ideal_functions.columns[1:])\n",
    "        for col in ys_columns:\n",
    "            filtered_data = mapped_test_data[mapped_test_data['ideal_functions_df'] == col]\n",
    "            p.scatter(x=filtered_data['x'], y=filtered_data['y'], size=8, color=\"red\", alpha=0.5, legend_label=col)\n",
    "        p.legend.location = \"top_left\"\n",
    "        bp.output_file(filename)\n",
    "        bp.save(p, filename)\n",
    "\n",
    "# Main function\n",
    "def main():\n",
    "    paths = ('train.csv', 'ideal.csv', 'test.csv')\n",
    "    ideal_selector = IdealFunctionSelector(*paths)\n",
    "    ideal_selector.preprocess_data()\n",
    "    ideal_selector.select_ideal_functions()\n",
    "    mapped_test_data = ideal_selector.test_data.join(ideal_selector.predict_ideal_function_nos())\n",
    "    filename = \"ideal_functions.html\"\n",
    "    bp.output_file(filename)\n",
    "    ideal_selector.visualize_results(mapped_test_data)\n",
    "    selected_functions = ideal_selector.get_selected_functions()\n",
    "    p_selected_functions = bp.figure(title=\"Selected Functions vs Test Data\", x_axis_label=\"x\", y_axis_label=\"y\")\n",
    "    source_selected_functions = ColumnDataSource(mapped_test_data)\n",
    "    p_selected_functions.scatter(x='x', y='y', size=10, color=\"blue\", alpha=0.5, legend_label=\"Test Data\", source=source_selected_functions)\n",
    "    for function_name, coefficients in selected_functions:\n",
    "        predicted_y_values = np.polyval(coefficients[::-1], mapped_test_data['x'])\n",
    "        p_selected_functions.line(x=mapped_test_data['x'], y=predicted_y_values, line_width=2, color=\"red\", alpha=0.5, legend_label=f'{function_name} (Selected Function)')\n",
    "    p_selected_functions.legend.location = \"top_left\"\n",
    "    filename_selected_functions = \"selected_functions_vs_test_data.html\"\n",
    "    bp.output_file(filename_selected_functions)\n",
    "    bp.save(p_selected_functions, filename_selected_functions)\n",
    "\n",
    "# Entry point\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b0df8649-d06b-4f51-963d-b4324c099f94",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
